// This code was generated by SqlHydra.SqlServer.
namespace SampleApp.AdventureWorks

type Column(reader: System.Data.IDataReader, getOrdinal, column) =
        member __.Name = column
        member __.IsNull() = getOrdinal column |> reader.IsDBNull

type RequiredColumn<'T, 'Reader when 'Reader :> System.Data.IDataReader>(reader: 'Reader, getOrdinal, getter: int -> 'T, column) =
        inherit Column(reader, getOrdinal, column)
        member __.Read() = getOrdinal column |> getter

type OptionalColumn<'T, 'Reader when 'Reader :> System.Data.IDataReader>(reader: 'Reader, getOrdinal, getter: int -> 'T, column) =
        inherit Column(reader, getOrdinal, column)
        member __.Read() = 
            match getOrdinal column with
            | o when reader.IsDBNull o -> None
            | o -> Some (getter o)

type RequiredBinaryColumn<'T, 'Reader when 'Reader :> System.Data.IDataReader>(reader: 'Reader, getOrdinal, getValue: int -> obj, column) =
        inherit Column(reader, getOrdinal, column)
        member __.Read() = getOrdinal column |> getValue :?> byte[]

type OptionalBinaryColumn<'T, 'Reader when 'Reader :> System.Data.IDataReader>(reader: 'Reader, getOrdinal, getValue: int -> obj, column) =
        inherit Column(reader, getOrdinal, column)
        member __.Read() = 
            match getOrdinal column with
            | o when reader.IsDBNull o -> None
            | o -> Some (getValue o :?> byte[])

module Readers =
                
    let splitEntityTypes<'T>() =
        let ti = typeof<'T>
        if ti.Name.StartsWith "Tuple"
        then ti.GetGenericArguments() |> Array.map (fun arg -> arg.Name)
        else [| ti.Name |]
        |> Array.toList

    let getColumnCountForTable (table: string) = 
        // table column counts to be generated somewhere...
        match table with 
        | "Product" -> 17
        | "ProductCategory" -> 5
        | _ -> failwith "not implemented"

    let splitAtPoints (segmentLengths: int seq) (lst: 'T list) =
        segmentLengths
        |> Seq.fold (fun (segments: 'T list list, remaining) len -> 
            let seg,rem = remaining |> List.splitAt len
            segments @ [seg], rem
        ) ([], lst)
        |> fst            

    let getOrdinalByEntity<'T>(reader: Microsoft.Data.SqlClient.SqlDataReader) = 
        let entityTypes = splitEntityTypes<'T>()
        let entityFieldCounts = entityTypes |> List.map getColumnCountForTable
        let totalFieldCount = entityFieldCounts |> List.sum
        let columnsOrdinals = [0..totalFieldCount-1] |> List.map reader.GetName |> List.indexed |> List.map (fun (i, nm) -> nm, i)
        let columnsOrdinalsSegmented = splitAtPoints entityFieldCounts columnsOrdinals
        let getOrdinalSegmented = columnsOrdinalsSegmented |> List.map Map.ofList|> List.map (fun m -> fun col -> m.Item col)
        List.zip entityTypes getOrdinalSegmented |> Map.ofList

        
module SalesLT =

    [<CLIMutable>]
    type Product =
        { ProductID: int
          Name: string
          ProductNumber: string
          StandardCost: decimal
          ListPrice: decimal
          SellStartDate: System.DateTime
          rowguid: System.Guid
          ModifiedDate: System.DateTime
          SellEndDate: Option<System.DateTime>
          DiscontinuedDate: Option<System.DateTime>
          ThumbNailPhoto: Option<byte []>
          ThumbnailPhotoFileName: Option<string>
          Size: Option<string>
          Weight: Option<decimal>
          ProductCategoryID: Option<int>
          ProductModelID: Option<int>
          Color: Option<string> }

    type ProductDataReader(reader: Microsoft.Data.SqlClient.SqlDataReader, getOrdinal) =
        member val ProductID = RequiredColumn(reader, getOrdinal, reader.GetInt32, "ProductID")
        member val Name = RequiredColumn(reader, getOrdinal, reader.GetString, "Name")
        member val ProductNumber = RequiredColumn(reader, getOrdinal, reader.GetString, "ProductNumber")
        member val StandardCost = RequiredColumn(reader, getOrdinal, reader.GetDecimal, "StandardCost")
        member val ListPrice = RequiredColumn(reader, getOrdinal, reader.GetDecimal, "ListPrice")
        member val SellStartDate = RequiredColumn(reader, getOrdinal, reader.GetDateTime, "SellStartDate")
        member val rowguid = RequiredColumn(reader, getOrdinal, reader.GetGuid, "rowguid")
        member val ModifiedDate = RequiredColumn(reader, getOrdinal, reader.GetDateTime, "ModifiedDate")
        member val SellEndDate = OptionalColumn(reader, getOrdinal, reader.GetDateTime, "SellEndDate")
        member val DiscontinuedDate = OptionalColumn(reader, getOrdinal, reader.GetDateTime, "DiscontinuedDate")
        member val ThumbNailPhoto = OptionalBinaryColumn(reader, getOrdinal, reader.GetValue, "ThumbNailPhoto")
        member val ThumbnailPhotoFileName = OptionalColumn(reader, getOrdinal, reader.GetString, "ThumbnailPhotoFileName")
        member val Size = OptionalColumn(reader, getOrdinal, reader.GetString, "Size")
        member val Weight = OptionalColumn(reader, getOrdinal, reader.GetDecimal, "Weight")
        member val ProductCategoryID = OptionalColumn(reader, getOrdinal, reader.GetInt32, "ProductCategoryID")
        member val ProductModelID = OptionalColumn(reader, getOrdinal, reader.GetInt32, "ProductModelID")
        member val Color = OptionalColumn(reader, getOrdinal, reader.GetString, "Color")
        member __.ToRecord() =
            { ProductID = __.ProductID.Read()
              Name = __.Name.Read()
              ProductNumber = __.ProductNumber.Read()
              StandardCost = __.StandardCost.Read()
              ListPrice = __.ListPrice.Read()
              SellStartDate = __.SellStartDate.Read()
              rowguid = __.rowguid.Read()
              ModifiedDate = __.ModifiedDate.Read()
              SellEndDate = __.SellEndDate.Read()
              DiscontinuedDate = __.DiscontinuedDate.Read()
              ThumbNailPhoto = __.ThumbNailPhoto.Read()
              ThumbnailPhotoFileName = __.ThumbnailPhotoFileName.Read()
              Size = __.Size.Read()
              Weight = __.Weight.Read()
              ProductCategoryID = __.ProductCategoryID.Read()
              ProductModelID = __.ProductModelID.Read()
              Color = __.Color.Read() }

        member __.ToRecordIf(column: Column) =
            if column.IsNull() then
                None
            else
                Some(__.ToRecord())

    [<CLIMutable>]
    type ProductCategory =
        { Name: string
          rowguid: System.Guid
          ModifiedDate: System.DateTime
          ProductCategoryID: int
          ParentProductCategoryID: Option<int> }

    type ProductCategoryDataReader(reader: Microsoft.Data.SqlClient.SqlDataReader, getOrdinal) =
        member val Name = RequiredColumn(reader, getOrdinal, reader.GetString, "Name")
        member val rowguid = RequiredColumn(reader, getOrdinal, reader.GetGuid, "rowguid")
        member val ModifiedDate = RequiredColumn(reader, getOrdinal, reader.GetDateTime, "ModifiedDate")
        member val ProductCategoryID = RequiredColumn(reader, getOrdinal, reader.GetInt32, "ProductCategoryID")
        member val ParentProductCategoryID = OptionalColumn(reader, getOrdinal, reader.GetInt32, "ParentProductCategoryID")
        member __.ToRecord() =
            { Name = __.Name.Read()
              rowguid = __.rowguid.Read()
              ModifiedDate = __.ModifiedDate.Read()
              ProductCategoryID = __.ProductCategoryID.Read()
              ParentProductCategoryID = __.ParentProductCategoryID.Read() }

        member __.ToRecordIf(column: Column) =
            if column.IsNull() then
                None
            else
                Some(__.ToRecord())
